{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ch9329py","text":"<p>Modern Python driver for the CH9329 USB HID device with a state-based API.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\udd0c State-based API - Direct control matching USB HID protocol</li> <li>\ud83d\udc27 Linux-tested - Tested on Linux (may work on other platforms via pyserial)</li> <li>\ud83c\udfaf Type-safe - Full type hints with mypy strict mode</li> <li>\ud83c\udfae Complete HID support - Keyboard, mouse, and media keys</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code># From GitHub\nuv add git+https://github.com/osoekawaitlab/ch9329py.git\n\n# Or with pip\npip install git+https://github.com/osoekawaitlab/ch9329py.git\n</code></pre> <p>See Installation Guide for details.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#basic-keyboard-input","title":"Basic Keyboard Input","text":"<pre><code>from ch9329py import CH9329Driver, SerialAdapter, KeyboardInput, KeyCode\n\nwith SerialAdapter(\"/dev/ttyUSB0\", 9600) as adapter:\n    with CH9329Driver(adapter) as driver:\n        # Press 'A' key\n        driver.send_keyboard_input(KeyboardInput(keys=[KeyCode.KEY_A]))\n        # Release (important!)\n        driver.send_keyboard_input(KeyboardInput())\n</code></pre>"},{"location":"#using-modifiers","title":"Using Modifiers","text":"<pre><code>from ch9329py import ModifierKey\n\n# Ctrl+C\ndriver.send_keyboard_input(KeyboardInput(\n    modifiers={ModifierKey.KEY_LEFTCTRL},\n    keys=[KeyCode.KEY_C]\n))\ndriver.send_keyboard_input(KeyboardInput())\n</code></pre>"},{"location":"#mouse-control","title":"Mouse Control","text":"<pre><code>from ch9329py import MouseInput, MouseButton\n\n# Move mouse\ndriver.send_mouse_input(MouseInput(x=10, y=10))\n\n# Click\ndriver.send_mouse_input(MouseInput(buttons={MouseButton.BTN_LEFT}))\ndriver.send_mouse_input(MouseInput())  # Release\n\n# Scroll\ndriver.send_mouse_input(MouseInput(scroll=5))\n</code></pre>"},{"location":"#media-keys","title":"Media Keys","text":"<pre><code>from ch9329py import MediaKeyInput, MediaKey\n\n# Play/pause\ndriver.send_media_key_input(MediaKeyInput(keys=[MediaKey.KEY_PLAYPAUSE]))\ndriver.send_media_key_input(MediaKeyInput())  # Release\n</code></pre>"},{"location":"#state-based-api","title":"State-Based API","text":"<p>This library uses a state-based API where you send complete input states:</p> <pre><code># Set state: A pressed\ndriver.send_keyboard_input(KeyboardInput(keys=[KeyCode.KEY_A]))\n\n# Set state: nothing pressed\ndriver.send_keyboard_input(KeyboardInput())\n</code></pre> <p>Key concepts: - Always release keys/buttons by sending empty input - Each input represents complete state, not a change - No automatic behavior - you control everything</p>"},{"location":"#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   CH9329Driver              \u2502  \u2190 Three methods: send_keyboard_input,\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     send_mouse_input, send_media_key_input\n\u2502   Protocol Layer            \u2502  \u2190 Packet building\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Communication Adapter     \u2502  \u2190 Serial abstraction\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Data Models (Pydantic)    \u2502  \u2190 KeyboardInput, MouseInput, MediaKeyInput\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Installation Guide - Setup and configuration</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Automated testing</li> <li>Accessibility tools</li> <li>Remote control systems</li> <li>Embedded system interfaces</li> <li>Home automation</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions welcome! Especially for: - Windows/macOS testing - Additional examples - Bug fixes</p>"},{"location":"#license","title":"License","text":"<p>MIT License - see LICENSE file for details.</p>"},{"location":"adr/","title":"Architecture Decision Records (ADR)","text":"<p>Key design decisions for ch9329py.</p>"},{"location":"adr/#adr-0001-state-based-api-design","title":"ADR-0001: State-Based API Design","text":"<p>Decision: Use state-based API (send complete input states) instead of event-based (press/release).</p> <p>Why: Matches USB HID protocol directly, no hidden state, predictable behavior.</p> <p>Read full ADR \u2192</p>"},{"location":"adr/#adr-0002-adopt-pydantic-for-data-models","title":"ADR-0002: Adopt Pydantic for Data Models","text":"<p>Decision: Use Pydantic v2 for input validation.</p> <p>Why: Runtime validation, type safety, clear error messages.</p> <p>Read full ADR \u2192</p>"},{"location":"adr/#adr-0003-adopt-evdev-as-domain-model","title":"ADR-0003: Adopt evdev as Domain Model","text":"<p>Decision: Use Linux evdev codes (KEY_A, BTN_LEFT) instead of raw USB HID codes.</p> <p>Why: Semantic naming, Linux standard, familiar to developers.</p> <p>Read full ADR \u2192</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10+</li> <li>Linux (tested), other platforms may work via pyserial</li> </ul>"},{"location":"installation/#install-from-github","title":"Install from GitHub","text":"<pre><code># Using uv (recommended)\nuv add git+https://github.com/osoekawaitlab/ch9329py.git\n\n# Using pip\npip install git+https://github.com/osoekawaitlab/ch9329py.git\n</code></pre>"},{"location":"installation/#linux-setup","title":"Linux Setup","text":""},{"location":"installation/#1-find-serial-port","title":"1. Find Serial Port","text":"<pre><code># USB-to-Serial adapter\nls /dev/ttyUSB*  # Usually /dev/ttyUSB0\n\n# Hardware UART\nls /dev/ttyS*    # /dev/ttyS0, /dev/serial0, etc.\n</code></pre>"},{"location":"installation/#2-grant-permissions","title":"2. Grant Permissions","text":"<pre><code># Add user to dialout group\nsudo usermod -a -G dialout $USER\n\n# Log out and back in for changes to take effect\n</code></pre>"},{"location":"installation/#3-verify","title":"3. Verify","text":"<pre><code>import ch9329py\nprint(ch9329py.__version__)  # Should print: 0.2.0\n</code></pre>"},{"location":"installation/#development-setup","title":"Development Setup","text":"<pre><code>git clone https://github.com/osoekawaitlab/ch9329py.git\ncd ch9329py\n\n# Install dependencies\nuv sync\n\n# Run tests\nuv run nox -s tests\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#permission-denied","title":"Permission Denied","text":"<pre><code>sudo usermod -a -G dialout $USER\n# Then log out and back in\n</code></pre>"},{"location":"installation/#device-not-found","title":"Device Not Found","text":"<pre><code># Check dmesg for device detection\ndmesg | grep tty\n\n# Verify device connection\nls -l /dev/ttyUSB0\n</code></pre>"},{"location":"installation/#import-error","title":"Import Error","text":"<pre><code># Verify installation\npip list | grep ch9329py\n\n# Reinstall if needed\npip uninstall ch9329py\npip install git+https://github.com/osoekawaitlab/ch9329py.git\n</code></pre>"},{"location":"installation/#platform-notes","title":"Platform Notes","text":"<p>Linux: Fully tested and supported.</p> <p>Windows/macOS: Not tested. May work since pyserial supports these platforms (use <code>COM3</code> on Windows, <code>/dev/tty.usbserial-*</code> on macOS). Contributions welcome!</p> <p>Docker: Grant device access with <code>--device=/dev/ttyUSB0</code></p> <p>WSL: Limited serial support. Consider native Linux or Windows.</p>"},{"location":"adr/0000-adr-template/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0000-adr-template/#title","title":"Title","text":"<p>Short title of the architectural decision</p>"},{"location":"adr/0000-adr-template/#status","title":"Status","text":"<p>[Proposed | Accepted | Deprecated | Superseded]</p>"},{"location":"adr/0000-adr-template/#date","title":"Date","text":"<p>YYYY-MM-DD</p>"},{"location":"adr/0000-adr-template/#context","title":"Context","text":"<p>Describe the context and problem statement. What is the architectural challenge that needs to be addressed? Include any relevant constraints or requirements that influenced the decision.</p>"},{"location":"adr/0000-adr-template/#decision","title":"Decision","text":"<p>State the architectural decision clearly and concisely. What specific approach, technology, pattern, or solution was chosen?</p>"},{"location":"adr/0000-adr-template/#rationale","title":"Rationale","text":"<p>Explain the reasoning that led to this decision. Why was this particular option selected among the alternatives? Include relevant factors such as:</p> <ul> <li>Technical considerations</li> <li>Business requirements</li> <li>Team capabilities</li> <li>Time constraints</li> <li>Cost implications</li> </ul>"},{"location":"adr/0000-adr-template/#implications","title":"Implications","text":""},{"location":"adr/0000-adr-template/#positive-implications","title":"Positive Implications","text":"<p>List the benefits and positive outcomes expected from this decision.</p>"},{"location":"adr/0000-adr-template/#concerns","title":"Concerns","text":"<p>List potential challenges, risks, or negative consequences along with possible mitigation strategies.</p>"},{"location":"adr/0000-adr-template/#alternatives","title":"Alternatives","text":"<p>Describe other options that were considered and why they were not selected. For each alternative, briefly explain:</p> <ul> <li>Key characteristics</li> <li>Pros and cons relative to the chosen solution</li> <li>Reasons for rejection</li> </ul>"},{"location":"adr/0000-adr-template/#future-direction","title":"Future Direction","text":"<p>Outline any follow-up actions, future considerations, or potential changes that might be necessary as a result of this decision. Include potential triggers for revisiting this decision.</p>"},{"location":"adr/0000-adr-template/#references","title":"References","text":"<p>List any relevant documents, articles, books, or other resources that supported this decision:</p> <ul> <li>Links to relevant documentation</li> <li>Research materials</li> <li>Benchmarks or performance data</li> <li>Team discussions or meeting notes</li> </ul>"},{"location":"adr/0001-state-based-api-design/","title":"ADR 0001: State-Based API Design","text":""},{"location":"adr/0001-state-based-api-design/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0001-state-based-api-design/#date","title":"Date","text":"<p>2025-11-05</p>"},{"location":"adr/0001-state-based-api-design/#context","title":"Context","text":"<p>CH9329 uses USB HID protocol which works by sending complete device state (all pressed keys/buttons) rather than discrete press/release events.</p>"},{"location":"adr/0001-state-based-api-design/#decision","title":"Decision","text":"<p>Implement state-based API with three core methods:</p> <ul> <li><code>send_keyboard_input(input_data: KeyboardInput)</code></li> <li><code>send_mouse_input(input_data: MouseInput)</code></li> <li><code>send_media_key_input(input_data: MediaKeyInput)</code></li> </ul> <p>Users send complete input states. Driver maintains no internal state.</p>"},{"location":"adr/0001-state-based-api-design/#rationale","title":"Rationale","text":"<ul> <li>Matches USB HID protocol: Direct mapping to hardware behavior</li> <li>Predictable: No hidden state, what you send is what device receives</li> <li>Testable: Each call is independent</li> <li>Precise control: Users control exact timing</li> </ul>"},{"location":"adr/0001-state-based-api-design/#implications","title":"Implications","text":"<p>Positive:</p> <ul> <li>Efficient (one packet per state change)</li> <li>No state synchronization issues</li> <li>Supports complex scenarios (6-key rollover, simultaneous buttons)</li> </ul> <p>Concerns:</p> <ul> <li>Verbose for simple operations (press + release requires two calls)</li> <li>Users must remember to release keys/buttons</li> </ul>"},{"location":"adr/0001-state-based-api-design/#alternatives","title":"Alternatives","text":"<p>Event-based API (press/release methods): Rejected because doesn't match HID semantics and requires driver to maintain state.</p> <p>Auto-release convenience methods: Rejected because hides behavior and prevents precise timing control.</p>"},{"location":"adr/0001-state-based-api-design/#references","title":"References","text":"<ul> <li>USB HID Specification: https://www.usb.org/hid</li> </ul>"},{"location":"adr/0002-adopt-pydantic-for-data-models/","title":"ADR 0002: Adopt Pydantic for Data Models","text":""},{"location":"adr/0002-adopt-pydantic-for-data-models/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0002-adopt-pydantic-for-data-models/#date","title":"Date","text":"<p>2025-11-05</p>"},{"location":"adr/0002-adopt-pydantic-for-data-models/#context","title":"Context","text":"<p>Input state models (<code>KeyboardInput</code>, <code>MouseInput</code>, <code>MediaKeyInput</code>) need validation to prevent invalid data from reaching the device (e.g., more than 6 keys, out-of-range mouse movement).</p>"},{"location":"adr/0002-adopt-pydantic-for-data-models/#decision","title":"Decision","text":"<p>Use Pydantic v2 for all input data models with Field validation.</p>"},{"location":"adr/0002-adopt-pydantic-for-data-models/#rationale","title":"Rationale","text":"<ul> <li>Runtime validation: Catches errors before sending to device</li> <li>Type safety: Integrates with mypy</li> <li>Clear error messages: ValidationError explains what's wrong</li> <li>Self-documenting: Field constraints serve as documentation</li> </ul>"},{"location":"adr/0002-adopt-pydantic-for-data-models/#implications","title":"Implications","text":"<p>Positive: - Invalid input caught early with clear errors - No need for manual validation code - Good developer experience (IDE autocomplete, type checking)</p> <p>Concerns: - Adds dependency on Pydantic - Slight performance overhead (negligible for HID use case)</p>"},{"location":"adr/0002-adopt-pydantic-for-data-models/#alternatives","title":"Alternatives","text":"<p>Manual validation: Rejected because error-prone and requires writing/maintaining validation logic.</p> <p>Dataclasses with custom validators: Rejected because reinventing what Pydantic already does well.</p>"},{"location":"adr/0002-adopt-pydantic-for-data-models/#references","title":"References","text":"<ul> <li>Pydantic documentation: https://docs.pydantic.dev/</li> </ul>"},{"location":"adr/0003-adopt-evdev-as-domain-model/","title":"ADR 003: Adopt evdev as Domain Model for Input Events","text":""},{"location":"adr/0003-adopt-evdev-as-domain-model/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0003-adopt-evdev-as-domain-model/#date","title":"Date","text":"<p>2025-11-03</p>"},{"location":"adr/0003-adopt-evdev-as-domain-model/#context","title":"Context","text":"<p>The CH9329 chip uses USB HID keycodes (e.g., 0x04 for 'A') internally. We need to choose a domain model for representing input events in the public API.</p> <p>The target deployment environment is Linux systems, and we want to support: - Keyboard input - Mouse operations - Game controller input - AI-generated input sequences</p>"},{"location":"adr/0003-adopt-evdev-as-domain-model/#decision","title":"Decision","text":"<p>Adopt the Linux <code>evdev</code> event code system as our domain model for input events.</p>"},{"location":"adr/0003-adopt-evdev-as-domain-model/#rationale","title":"Rationale","text":"<ol> <li>Standardization - evdev is the Linux standard for input events</li> <li>Broad Coverage - Supports keyboard (KEY_), mouse (BTN_, REL_, ABS_), and game controllers (BTN_A, ABS_RX, etc.)</li> <li>AI-Friendly - Well-documented, semantic names make it easier for AI to generate input sequences</li> <li>Developer-Friendly - Linux developers are familiar with evdev concepts and naming</li> </ol>"},{"location":"adr/0003-adopt-evdev-as-domain-model/#implications","title":"Implications","text":""},{"location":"adr/0003-adopt-evdev-as-domain-model/#positive","title":"Positive","text":"<ul> <li>Unified abstraction for diverse input devices</li> <li>Rich ecosystem and documentation</li> <li>Clear, semantic event names</li> </ul>"},{"location":"adr/0003-adopt-evdev-as-domain-model/#concerns","title":"Concerns","text":"<ul> <li>Requires translation layer from evdev codes to USB HID codes</li> <li>Not all evdev events are supported by CH9329</li> <li>Need clear error handling for unsupported events</li> </ul>"},{"location":"adr/0003-adopt-evdev-as-domain-model/#alternatives","title":"Alternatives","text":""},{"location":"adr/0003-adopt-evdev-as-domain-model/#use-usb-hid-codes-directly","title":"Use USB HID Codes Directly","text":"<p>Keep the current approach using raw USB HID keycodes.</p> <p>Rejected because: - Less semantic (0x04 vs KEY_A) - Harder for AI to generate correct sequences - Limited to keyboard/mouse, doesn't extend well to controllers</p>"},{"location":"adr/0003-adopt-evdev-as-domain-model/#create-custom-abstraction","title":"Create Custom Abstraction","text":"<p>Design our own event system.</p> <p>Rejected because: - Reinventing the wheel - Less familiar to developers - Would still need to map to something standard</p>"},{"location":"adr/0003-adopt-evdev-as-domain-model/#future-direction","title":"Future Direction","text":"<ul> <li>Implement evdev to USB HID translation layer</li> <li>Define explicitly supported event types</li> <li>Add validation with clear error messages for unsupported events</li> </ul>"},{"location":"adr/0003-adopt-evdev-as-domain-model/#references","title":"References","text":"<ul> <li>Linux evdev documentation: https://www.kernel.org/doc/Documentation/input/event-codes.txt</li> <li>python-evdev library: https://python-evdev.readthedocs.io/</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for ch9329py.</p>"},{"location":"api/#modules","title":"Modules","text":"<ul> <li>Driver - High-level API for controlling the CH9329 device</li> <li>Adapter - Communication layer for serial connections</li> <li>Protocol - Low-level packet building</li> <li>Models - Data models and enums</li> </ul>"},{"location":"api/#quick-links","title":"Quick Links","text":""},{"location":"api/#main-classes","title":"Main Classes","text":"<ul> <li><code>CH9329Driver</code> - Main driver class</li> <li><code>SerialAdapter</code> - Serial communication adapter</li> <li><code>CommunicationAdapter</code> - Abstract adapter base class</li> </ul>"},{"location":"api/#data-models","title":"Data Models","text":"<ul> <li><code>KeyboardInput</code> - Keyboard input state</li> <li><code>MouseInput</code> - Mouse input state</li> <li><code>MediaKeyInput</code> - Media key input state</li> </ul>"},{"location":"api/#enums","title":"Enums","text":"<ul> <li><code>KeyCode</code> - Keyboard key codes</li> <li><code>ModifierKey</code> - Keyboard modifiers (Ctrl, Shift, etc.)</li> <li><code>MouseButton</code> - Mouse button constants</li> <li><code>MediaKey</code> - Media control keys</li> </ul>"},{"location":"api/#protocol","title":"Protocol","text":"<ul> <li><code>CH9329Protocol</code> - Protocol packet builder</li> </ul>"},{"location":"api/#usage-pattern","title":"Usage Pattern","text":"<p>The typical usage pattern involves three main components:</p> <pre><code>from ch9329py import CH9329Driver, SerialAdapter, KeyboardInput, KeyCode\n\n# 1. Create adapter (communication layer)\nadapter = SerialAdapter(\"/dev/ttyUSB0\", 9600)\n\n# 2. Create driver (high-level API)\ndriver = CH9329Driver(adapter)\n\n# 3. Use the driver (state-based API)\ndriver.send_keyboard_input(KeyboardInput(keys=[KeyCode.KEY_H, KeyCode.KEY_I]))\ndriver.send_keyboard_input(KeyboardInput())  # Release\ndriver.close()\n</code></pre> <p>Or with context managers (recommended):</p> <pre><code>from ch9329py import CH9329Driver, SerialAdapter, KeyboardInput, KeyCode\n\nwith SerialAdapter(\"/dev/ttyUSB0\", 9600) as adapter:\n    with CH9329Driver(adapter) as driver:\n        # Press keys\n        driver.send_keyboard_input(KeyboardInput(keys=[KeyCode.KEY_A]))\n        # Release keys\n        driver.send_keyboard_input(KeyboardInput())\n</code></pre>"},{"location":"api/#type-safety","title":"Type Safety","text":"<p>All classes and functions in ch9329py are fully type-annotated and checked with mypy in strict mode. This means you get:</p> <ul> <li>Autocomplete in IDEs</li> <li>Type checking at development time</li> <li>Better documentation</li> <li>Fewer runtime errors</li> </ul> <p>Example:</p> <pre><code>from ch9329py import CH9329Driver, KeyboardInput, KeyCode\n\ndef automate_task(driver: CH9329Driver) -&gt; None:\n    \"\"\"Automate a task with type checking.\"\"\"\n    # \u2713 Type checks - KeyboardInput with KeyCode enum\n    driver.send_keyboard_input(KeyboardInput(keys=[KeyCode.KEY_A]))\n\n    # \u2717 Type error: str is not KeyCode\n    # driver.send_keyboard_input(KeyboardInput(keys=[\"A\"]))\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":"<p>The library uses custom exceptions from the <code>exceptions</code> module:</p> <ul> <li><code>CH9329PyError</code> - Base exception for all library errors</li> <li><code>UnsupportedEvdevCodeError</code> - For unsupported evdev codes</li> </ul> <p>Standard Python exceptions are also raised:</p> <ul> <li><code>ValueError</code> - For invalid input values (e.g., out of range mouse movement)</li> <li><code>TypeError</code> - For type mismatches</li> </ul> <p>Example:</p> <pre><code>from ch9329py import (\n    CH9329Driver,\n    SerialAdapter,\n    KeyboardInput,\n    KeyCode,\n    CH9329PyError,\n)\n\ntry:\n    adapter = SerialAdapter(\"/dev/invalid\", 9600)\nexcept Exception as e:\n    print(f\"Failed to connect: {e}\")\n\ntry:\n    # Invalid mouse movement (out of range)\n    from ch9329py import MouseInput\n    driver.send_mouse_input(MouseInput(x=200))  # Max is 127\nexcept ValueError as e:\n    print(f\"Invalid value: {e}\")\n</code></pre>"},{"location":"api/#extension-points","title":"Extension Points","text":""},{"location":"api/#custom-adapters","title":"Custom Adapters","text":"<p>You can create custom communication adapters by implementing the <code>CommunicationAdapter</code> interface:</p> <pre><code>from ch9329py import CommunicationAdapter, CH9329Driver\n\nclass NetworkAdapter(CommunicationAdapter):\n    \"\"\"Send commands over network instead of serial.\"\"\"\n\n    def send(self, data: bytes) -&gt; bytes:\n        # Your network implementation\n        pass\n\n    def close(self) -&gt; None:\n        # Cleanup\n        pass\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()\n\n# Use your custom adapter\nadapter = NetworkAdapter()\ndriver = CH9329Driver(adapter)\n</code></pre>"},{"location":"api/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/#command-timing","title":"Command Timing","text":"<p>Each command is sent immediately to the device. For proper timing between keystrokes, use <code>time.sleep()</code>:</p> <pre><code>import time\nfrom ch9329py import KeyboardInput, KeyCode\n\n# Type with delay between keys\ndriver.send_keyboard_input(KeyboardInput(keys=[KeyCode.KEY_A]))\ndriver.send_keyboard_input(KeyboardInput())\ntime.sleep(0.05)\n\ndriver.send_keyboard_input(KeyboardInput(keys=[KeyCode.KEY_B]))\ndriver.send_keyboard_input(KeyboardInput())\n</code></pre>"},{"location":"api/#multiple-keys-at-once","title":"Multiple Keys at Once","text":"<p>The CH9329 supports up to 6 simultaneous keys, which is more efficient than pressing keys individually:</p> <pre><code># Efficient: Press multiple keys at once\ndriver.send_keyboard_input(KeyboardInput(\n    keys=[KeyCode.KEY_A, KeyCode.KEY_B, KeyCode.KEY_C]\n))\ndriver.send_keyboard_input(KeyboardInput())\n</code></pre>"},{"location":"api/#thread-safety","title":"Thread Safety","text":"<p>The library is not thread-safe. If you need concurrent access, use proper locking:</p> <pre><code>import threading\nfrom ch9329py import CH9329Driver, SerialAdapter, KeyboardInput, KeyCode\n\nadapter = SerialAdapter(\"/dev/ttyUSB0\", 9600)\ndriver = CH9329Driver(adapter)\nlock = threading.Lock()\n\ndef task1():\n    with lock:\n        driver.send_keyboard_input(KeyboardInput(keys=[KeyCode.KEY_A]))\n        driver.send_keyboard_input(KeyboardInput())\n\ndef task2():\n    with lock:\n        driver.send_keyboard_input(KeyboardInput(keys=[KeyCode.KEY_B]))\n        driver.send_keyboard_input(KeyboardInput())\n\n# Run tasks in threads\nt1 = threading.Thread(target=task1)\nt2 = threading.Thread(target=task2)\nt1.start()\nt2.start()\nt1.join()\nt2.join()\n</code></pre>"},{"location":"api/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always use context managers for automatic cleanup:    <pre><code>with SerialAdapter(\"/dev/ttyUSB0\", 9600) as adapter:\n    with CH9329Driver(adapter) as driver:\n        driver.send_keyboard_input(KeyboardInput(keys=[KeyCode.KEY_A]))\n        driver.send_keyboard_input(KeyboardInput())\n</code></pre></p> </li> <li> <p>Always release keys/buttons after pressing:    <pre><code># Press\ndriver.send_keyboard_input(KeyboardInput(keys=[KeyCode.KEY_A]))\n# Release (DON'T FORGET!)\ndriver.send_keyboard_input(KeyboardInput())\n</code></pre></p> </li> <li> <p>Handle errors gracefully:    <pre><code>try:\n    from ch9329py import MouseInput\n    driver.send_mouse_input(MouseInput(x=10, y=10))\nexcept ValueError as e:\n    print(f\"Invalid input: {e}\")\n</code></pre></p> </li> <li> <p>Use type hints in your code:    <pre><code>def my_function(driver: CH9329Driver) -&gt; None:\n    from ch9329py import KeyboardInput, KeyCode\n    driver.send_keyboard_input(KeyboardInput(keys=[KeyCode.KEY_A]))\n    driver.send_keyboard_input(KeyboardInput())\n</code></pre></p> </li> </ol>"},{"location":"api/#see-also","title":"See Also","text":"<ul> <li>Home - Getting started and examples</li> <li>Installation - Installation instructions</li> </ul>"},{"location":"api/adapter/","title":"Adapter Module","text":""},{"location":"api/adapter/#ch9329py.adapter","title":"<code>adapter</code>","text":"<p>Communication adapters for CH9329 device.</p> <p>This module provides communication adapters for interacting with the CH9329 device. The abstract base class allows for dependency injection and easy testing with mock implementations.</p>"},{"location":"api/adapter/#ch9329py.adapter-classes","title":"Classes","text":""},{"location":"api/adapter/#ch9329py.adapter.CommunicationAdapter","title":"<code>CommunicationAdapter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for communication adapters.</p> <p>This class defines the interface for communicating with the CH9329 device. Concrete implementations handle the actual communication protocol (e.g., serial).</p>"},{"location":"api/adapter/#ch9329py.adapter.CommunicationAdapter-functions","title":"Functions","text":""},{"location":"api/adapter/#ch9329py.adapter.CommunicationAdapter.send","title":"<code>send(data)</code>  <code>abstractmethod</code>","text":"<p>Send data to the device and receive response.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Bytes to send to the device.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Response bytes from the device.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If communication fails.</p> Source code in <code>src/ch9329py/adapter.py</code> <pre><code>@abstractmethod\ndef send(self, data: bytes) -&gt; bytes:\n    \"\"\"Send data to the device and receive response.\n\n    Args:\n        data: Bytes to send to the device.\n\n    Returns:\n        Response bytes from the device.\n\n    Raises:\n        ConnectionError: If communication fails.\n    \"\"\"\n</code></pre>"},{"location":"api/adapter/#ch9329py.adapter.CommunicationAdapter.close","title":"<code>close()</code>  <code>abstractmethod</code>","text":"<p>Close the communication channel.</p> <p>This should clean up any resources (e.g., close serial port).</p> Source code in <code>src/ch9329py/adapter.py</code> <pre><code>@abstractmethod\ndef close(self) -&gt; None:\n    \"\"\"Close the communication channel.\n\n    This should clean up any resources (e.g., close serial port).\n    \"\"\"\n</code></pre>"},{"location":"api/adapter/#ch9329py.adapter.SerialAdapter","title":"<code>SerialAdapter(port, baudrate=9600, timeout=0.1, write_read_delay=0.02)</code>","text":"<p>               Bases: <code>CommunicationAdapter</code></p> <p>Serial communication adapter for CH9329 device.</p> <p>This adapter uses pyserial to communicate with the CH9329 device over a serial connection (USB, UART, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>Serial port path (e.g., \"/dev/ttyUSB0\" on Linux, \"COM5\" on Windows).</p> required <code>baudrate</code> <code>int</code> <p>Communication speed in bits per second (default: 9600).</p> <code>9600</code> <code>timeout</code> <code>float</code> <p>Read timeout in seconds (default: 0.1).</p> <code>0.1</code> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the serial port cannot be opened.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; adapter = SerialAdapter(\"/dev/ttyUSB0\", 9600)\n&gt;&gt;&gt; response = adapter.send(b\"\\x57\\xAB\\x00\\x02\\x08\")\n&gt;&gt;&gt; adapter.close()\n</code></pre> <p>Or using context manager:</p> <pre><code>&gt;&gt;&gt; with SerialAdapter(\"/dev/ttyUSB0\", 9600) as adapter:\n...     response = adapter.send(b\"\\x57\\xAB\\x00\\x02\\x08\")\n</code></pre> <p>Initialize serial adapter and open connection.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>Serial port path.</p> required <code>baudrate</code> <code>int</code> <p>Communication speed in bits per second.</p> <code>9600</code> <code>timeout</code> <code>float</code> <p>Read timeout in seconds.</p> <code>0.1</code> <code>write_read_delay</code> <code>float</code> <p>Delay between write and read in seconds.</p> <code>0.02</code> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the serial port cannot be opened.</p> Source code in <code>src/ch9329py/adapter.py</code> <pre><code>def __init__(\n    self,\n    port: str,\n    baudrate: int = 9600,\n    timeout: float = 0.1,\n    write_read_delay: float = 0.02,\n) -&gt; None:\n    \"\"\"Initialize serial adapter and open connection.\n\n    Args:\n        port: Serial port path.\n        baudrate: Communication speed in bits per second.\n        timeout: Read timeout in seconds.\n        write_read_delay: Delay between write and read in seconds.\n\n    Raises:\n        ConnectionError: If the serial port cannot be opened.\n    \"\"\"\n    self._write_read_delay = write_read_delay\n    try:\n        self._serial = serial.Serial(\n            port=port,\n            baudrate=baudrate,\n            timeout=timeout,\n        )\n        # Open the port if it's not already open\n        if not self._serial.is_open:\n            self._serial.open()\n    except (OSError, serial.SerialException) as e:\n        msg = f\"Failed to open serial port {port}: {e}\"\n        raise ConnectionError(msg) from e\n</code></pre>"},{"location":"api/adapter/#ch9329py.adapter.SerialAdapter-functions","title":"Functions","text":""},{"location":"api/adapter/#ch9329py.adapter.SerialAdapter.send","title":"<code>send(data)</code>","text":"<p>Send data to the device and receive response.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Bytes to send to the device.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Response bytes from the device (7 bytes).</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the serial port is not open or communication fails.</p> Source code in <code>src/ch9329py/adapter.py</code> <pre><code>def send(self, data: bytes) -&gt; bytes:\n    \"\"\"Send data to the device and receive response.\n\n    Args:\n        data: Bytes to send to the device.\n\n    Returns:\n        Response bytes from the device (7 bytes).\n\n    Raises:\n        ConnectionError: If the serial port is not open or communication fails.\n    \"\"\"\n    if not self._serial.is_open:\n        msg = \"Serial port is not open\"\n        raise ConnectionError(msg)\n\n    try:\n        # Write data to serial port\n        self._serial.write(data)\n\n        # Wait for device to process\n        time.sleep(self._write_read_delay)\n\n        # Read response\n        return self._serial.read(self._RESPONSE_LENGTH)\n    except serial.SerialException as e:\n        msg = f\"Serial communication failed: {e}\"\n        raise ConnectionError(msg) from e\n</code></pre>"},{"location":"api/adapter/#ch9329py.adapter.SerialAdapter.close","title":"<code>close()</code>","text":"<p>Close the serial port.</p> Source code in <code>src/ch9329py/adapter.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the serial port.\"\"\"\n    if hasattr(self, \"_serial\") and self._serial.is_open:\n        self._serial.close()\n</code></pre>"},{"location":"api/driver/","title":"Driver Module","text":""},{"location":"api/driver/#ch9329py.driver","title":"<code>driver</code>","text":"<p>Main driver class for CH9329 USB HID device.</p> <p>This module provides the low-level API for interacting with the CH9329 device.</p>"},{"location":"api/driver/#ch9329py.driver-classes","title":"Classes","text":""},{"location":"api/driver/#ch9329py.driver.CH9329Driver","title":"<code>CH9329Driver(adapter)</code>","text":"<p>Low-level driver for CH9329 USB HID device.</p> <p>This class provides direct state-based API for keyboard, mouse, and media key simulation through the CH9329 chip.</p> <p>Parameters:</p> Name Type Description Default <code>adapter</code> <code>CommunicationAdapter</code> <p>Communication adapter for sending/receiving data.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from ch9329py.adapter import SerialAdapter\n&gt;&gt;&gt; from ch9329py.driver import CH9329Driver\n&gt;&gt;&gt; from ch9329py.models import KeyboardInput, KeyCode\n&gt;&gt;&gt; adapter = SerialAdapter(\"/dev/ttyUSB0\", 9600)\n&gt;&gt;&gt; driver = CH9329Driver(adapter)\n&gt;&gt;&gt; state = KeyboardInput(keys=[KeyCode.KEY_A])\n&gt;&gt;&gt; driver.send_keyboard_input(state)\n&gt;&gt;&gt; driver.close()\n</code></pre> <p>Or using context manager:</p> <pre><code>&gt;&gt;&gt; with SerialAdapter(\"/dev/ttyUSB0\", 9600) as adapter:\n...     with CH9329Driver(adapter) as driver:\n...         state = KeyboardInput(keys=[KeyCode.KEY_A])\n...         driver.send_keyboard_input(state)\n</code></pre> <p>Initialize the CH9329 driver.</p> <p>Parameters:</p> Name Type Description Default <code>adapter</code> <code>CommunicationAdapter</code> <p>Communication adapter for sending/receiving data.</p> required Source code in <code>src/ch9329py/driver.py</code> <pre><code>def __init__(\n    self,\n    adapter: CommunicationAdapter,\n) -&gt; None:\n    \"\"\"Initialize the CH9329 driver.\n\n    Args:\n        adapter: Communication adapter for sending/receiving data.\n    \"\"\"\n    self._adapter = adapter\n</code></pre>"},{"location":"api/driver/#ch9329py.driver.CH9329Driver-functions","title":"Functions","text":""},{"location":"api/driver/#ch9329py.driver.CH9329Driver.send_keyboard_input","title":"<code>send_keyboard_input(input_data)</code>","text":"<p>Send a complete keyboard input with multiple keys and modifiers.</p> <p>This is a low-level API that directly exposes CH9329's capability to send up to 6 simultaneous key presses with 8 modifier keys.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>KeyboardInput</code> <p>The keyboard input containing modifiers and keys.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Press Ctrl+Shift+A\n&gt;&gt;&gt; input_data = KeyboardInput(\n...     modifiers={ModifierKey.KEY_LEFTCTRL, ModifierKey.KEY_LEFTSHIFT},\n...     keys=[KeyCode.KEY_A]\n... )\n&gt;&gt;&gt; driver.send_keyboard_input(input_data)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Press A+B+C simultaneously with Shift\n&gt;&gt;&gt; input_data = KeyboardInput(\n...     modifiers={ModifierKey.KEY_LEFTSHIFT},\n...     keys=[KeyCode.KEY_A, KeyCode.KEY_B, KeyCode.KEY_C]\n... )\n&gt;&gt;&gt; driver.send_keyboard_input(input_data)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Maximum 6 keys at once\n&gt;&gt;&gt; input_data = KeyboardInput(\n...     keys=[KeyCode.KEY_A, KeyCode.KEY_B, KeyCode.KEY_C,\n...           KeyCode.KEY_D, KeyCode.KEY_E, KeyCode.KEY_F]\n... )\n&gt;&gt;&gt; driver.send_keyboard_input(input_data)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Release all keys\n&gt;&gt;&gt; driver.send_keyboard_input(KeyboardInput())\n</code></pre> Source code in <code>src/ch9329py/driver.py</code> <pre><code>def send_keyboard_input(self, input_data: KeyboardInput) -&gt; None:\n    \"\"\"Send a complete keyboard input with multiple keys and modifiers.\n\n    This is a low-level API that directly exposes CH9329's capability\n    to send up to 6 simultaneous key presses with 8 modifier keys.\n\n    Args:\n        input_data: The keyboard input containing modifiers and keys.\n\n    Examples:\n        &gt;&gt;&gt; # Press Ctrl+Shift+A\n        &gt;&gt;&gt; input_data = KeyboardInput(\n        ...     modifiers={ModifierKey.KEY_LEFTCTRL, ModifierKey.KEY_LEFTSHIFT},\n        ...     keys=[KeyCode.KEY_A]\n        ... )\n        &gt;&gt;&gt; driver.send_keyboard_input(input_data)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Press A+B+C simultaneously with Shift\n        &gt;&gt;&gt; input_data = KeyboardInput(\n        ...     modifiers={ModifierKey.KEY_LEFTSHIFT},\n        ...     keys=[KeyCode.KEY_A, KeyCode.KEY_B, KeyCode.KEY_C]\n        ... )\n        &gt;&gt;&gt; driver.send_keyboard_input(input_data)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Maximum 6 keys at once\n        &gt;&gt;&gt; input_data = KeyboardInput(\n        ...     keys=[KeyCode.KEY_A, KeyCode.KEY_B, KeyCode.KEY_C,\n        ...           KeyCode.KEY_D, KeyCode.KEY_E, KeyCode.KEY_F]\n        ... )\n        &gt;&gt;&gt; driver.send_keyboard_input(input_data)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Release all keys\n        &gt;&gt;&gt; driver.send_keyboard_input(KeyboardInput())\n    \"\"\"\n    # Build modifier byte from evdev modifier keys\n    modifier_byte = 0x00\n    for modifier_key in input_data.modifiers:\n        modifier_byte |= evdev_to_usb_hid_modifier(modifier_key.value)\n\n    # Convert evdev key codes to USB HID scan codes\n    usb_hid_keys = [evdev_to_usb_hid_keyboard(key.value) for key in input_data.keys]\n\n    # Pad to 6 keys with zeros\n    while len(usb_hid_keys) &lt; MAX_ROLLOVER_KEYS:\n        usb_hid_keys.append(0x00)\n\n    # Build packet: [modifier, reserved, key1, key2, key3, key4, key5, key6]\n    # This directly corresponds to USB HID keyboard report format\n    data = [modifier_byte, 0x00, *usb_hid_keys]\n    packet = [0x57, 0xAB, 0x00, 0x02, len(data), *data]\n    checksum = sum(packet) &amp; 0xFF\n    packet.append(checksum)\n\n    self._adapter.send(bytes(packet))\n</code></pre>"},{"location":"api/driver/#ch9329py.driver.CH9329Driver.send_mouse_input","title":"<code>send_mouse_input(input_data)</code>","text":"<p>Send a complete mouse input with buttons, movement, and scroll.</p> <p>This is a low-level API that directly exposes CH9329's capability to send multiple simultaneous mouse button presses along with relative movement and scroll in a single packet.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>MouseInput</code> <p>The mouse input containing buttons, movement, and scroll.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Move right and down\n&gt;&gt;&gt; input_data = MouseInput(x=10, y=10)\n&gt;&gt;&gt; driver.send_mouse_input(input_data)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Left button pressed while moving\n&gt;&gt;&gt; input_data = MouseInput(\n...     buttons={MouseButton.BTN_LEFT},\n...     x=5,\n...     y=-5\n... )\n&gt;&gt;&gt; driver.send_mouse_input(input_data)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Multiple buttons with scroll\n&gt;&gt;&gt; input_data = MouseInput(\n...     buttons={MouseButton.BTN_LEFT, MouseButton.BTN_RIGHT},\n...     scroll=3\n... )\n&gt;&gt;&gt; driver.send_mouse_input(input_data)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Drag operation\n&gt;&gt;&gt; # Press and hold\n&gt;&gt;&gt; driver.send_mouse_input(MouseInput(buttons={MouseButton.BTN_LEFT}))\n&gt;&gt;&gt; # Move while holding\n&gt;&gt;&gt; driver.send_mouse_input(MouseInput(\n...     buttons={MouseButton.BTN_LEFT},\n...     x=10, y=10\n... ))\n&gt;&gt;&gt; # Release\n&gt;&gt;&gt; driver.send_mouse_input(MouseInput())\n</code></pre> Source code in <code>src/ch9329py/driver.py</code> <pre><code>def send_mouse_input(self, input_data: MouseInput) -&gt; None:\n    \"\"\"Send a complete mouse input with buttons, movement, and scroll.\n\n    This is a low-level API that directly exposes CH9329's capability\n    to send multiple simultaneous mouse button presses along with\n    relative movement and scroll in a single packet.\n\n    Args:\n        input_data: The mouse input containing buttons, movement, and scroll.\n\n    Examples:\n        &gt;&gt;&gt; # Move right and down\n        &gt;&gt;&gt; input_data = MouseInput(x=10, y=10)\n        &gt;&gt;&gt; driver.send_mouse_input(input_data)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Left button pressed while moving\n        &gt;&gt;&gt; input_data = MouseInput(\n        ...     buttons={MouseButton.BTN_LEFT},\n        ...     x=5,\n        ...     y=-5\n        ... )\n        &gt;&gt;&gt; driver.send_mouse_input(input_data)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Multiple buttons with scroll\n        &gt;&gt;&gt; input_data = MouseInput(\n        ...     buttons={MouseButton.BTN_LEFT, MouseButton.BTN_RIGHT},\n        ...     scroll=3\n        ... )\n        &gt;&gt;&gt; driver.send_mouse_input(input_data)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Drag operation\n        &gt;&gt;&gt; # Press and hold\n        &gt;&gt;&gt; driver.send_mouse_input(MouseInput(buttons={MouseButton.BTN_LEFT}))\n        &gt;&gt;&gt; # Move while holding\n        &gt;&gt;&gt; driver.send_mouse_input(MouseInput(\n        ...     buttons={MouseButton.BTN_LEFT},\n        ...     x=10, y=10\n        ... ))\n        &gt;&gt;&gt; # Release\n        &gt;&gt;&gt; driver.send_mouse_input(MouseInput())\n    \"\"\"\n    # Build button byte from evdev button codes\n    button_byte = 0x00\n    for button in input_data.buttons:\n        button_byte |= evdev_to_usb_hid_mouse(button.value)\n\n    # Build packet using protocol\n    packet = CH9329Protocol.build_mouse_rel_packet(\n        button_byte, input_data.x, input_data.y, input_data.scroll\n    )\n    self._adapter.send(packet)\n</code></pre>"},{"location":"api/driver/#ch9329py.driver.CH9329Driver.send_media_key_input","title":"<code>send_media_key_input(input_data)</code>","text":"<p>Send a media key input.</p> <p>This is a low-level API that directly sends media key state. Unlike keyboard input which supports 6 simultaneous keys, media keys only support single key at a time.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>MediaKeyInput</code> <p>The media key input containing keys to press or release.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Mute audio (press)\n&gt;&gt;&gt; input_data = MediaKeyInput(keys=[MediaKey.KEY_MUTE])\n&gt;&gt;&gt; driver.send_media_key_input(input_data)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Play/pause media (press)\n&gt;&gt;&gt; input_data = MediaKeyInput(keys=[MediaKey.KEY_PLAYPAUSE])\n&gt;&gt;&gt; driver.send_media_key_input(input_data)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Adjust volume (press)\n&gt;&gt;&gt; input_data = MediaKeyInput(keys=[MediaKey.KEY_VOLUMEUP])\n&gt;&gt;&gt; driver.send_media_key_input(input_data)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Release all keys\n&gt;&gt;&gt; input_data = MediaKeyInput(keys=[])\n&gt;&gt;&gt; driver.send_media_key_input(input_data)\n</code></pre> Source code in <code>src/ch9329py/driver.py</code> <pre><code>def send_media_key_input(self, input_data: MediaKeyInput) -&gt; None:\n    \"\"\"Send a media key input.\n\n    This is a low-level API that directly sends media key state.\n    Unlike keyboard input which supports 6 simultaneous keys,\n    media keys only support single key at a time.\n\n    Args:\n        input_data: The media key input containing keys to press or release.\n\n    Examples:\n        &gt;&gt;&gt; # Mute audio (press)\n        &gt;&gt;&gt; input_data = MediaKeyInput(keys=[MediaKey.KEY_MUTE])\n        &gt;&gt;&gt; driver.send_media_key_input(input_data)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Play/pause media (press)\n        &gt;&gt;&gt; input_data = MediaKeyInput(keys=[MediaKey.KEY_PLAYPAUSE])\n        &gt;&gt;&gt; driver.send_media_key_input(input_data)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Adjust volume (press)\n        &gt;&gt;&gt; input_data = MediaKeyInput(keys=[MediaKey.KEY_VOLUMEUP])\n        &gt;&gt;&gt; driver.send_media_key_input(input_data)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Release all keys\n        &gt;&gt;&gt; input_data = MediaKeyInput(keys=[])\n        &gt;&gt;&gt; driver.send_media_key_input(input_data)\n    \"\"\"\n    if not input_data.keys:\n        # Empty keys list means release all media keys\n        packet = CH9329Protocol.build_media_release_packet()\n        self._adapter.send(packet)\n    else:\n        # Press the single media key\n        # Extract the 4-byte media key code from the enum value\n        data0, data1, data2, data3 = input_data.keys[0].value\n\n        # Build packet using protocol\n        packet = CH9329Protocol.build_media_press_packet(data0, data1, data2, data3)\n        self._adapter.send(packet)\n</code></pre>"},{"location":"api/driver/#ch9329py.driver.CH9329Driver.close","title":"<code>close()</code>","text":"<p>Close the connection to the device.</p> Source code in <code>src/ch9329py/driver.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the connection to the device.\"\"\"\n    self._adapter.close()\n</code></pre>"},{"location":"api/driver/#ch9329py.driver-functions","title":"Functions","text":""},{"location":"api/models/","title":"Models Module","text":""},{"location":"api/models/#ch9329py.models","title":"<code>models</code>","text":"<p>Data models for CH9329 USB HID device.</p> <p>This module contains enums and functions for representing keyboard keys, mouse buttons, media keys, and character-to-keycode mappings.</p> <p>All key and button codes follow the Linux evdev naming convention.</p>"},{"location":"api/models/#ch9329py.models-classes","title":"Classes","text":""},{"location":"api/models/#ch9329py.models.MouseButton","title":"<code>MouseButton</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Mouse button constants for CH9329 device.</p> <p>These values follow evdev button code naming and values.</p>"},{"location":"api/models/#ch9329py.models.ModifierKey","title":"<code>ModifierKey</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Keyboard modifier key constants.</p> <p>These values follow evdev key code naming and values.</p>"},{"location":"api/models/#ch9329py.models.KeyCode","title":"<code>KeyCode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Keyboard key codes for CH9329 device.</p> <p>These values follow evdev key code naming and values.</p>"},{"location":"api/models/#ch9329py.models.MediaKey","title":"<code>MediaKey</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Media control key constants.</p> <p>These values follow evdev key code naming convention. Values are tuples of (byte1, byte2, byte3, byte4) that represent the media control packet data.</p>"},{"location":"api/models/#ch9329py.models.BaseCh9329Model","title":"<code>BaseCh9329Model</code>  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model for CH9329 input models.</p> <p>Configured to use enum values directly during serialization.</p> Show JSON schema: <pre><code>{\n  \"description\": \"Base model for CH9329 input models.\\n\\nConfigured to use enum values directly during serialization.\",\n  \"properties\": {},\n  \"title\": \"BaseCh9329Model\",\n  \"type\": \"object\"\n}\n</code></pre>"},{"location":"api/models/#ch9329py.models.KeyboardInput","title":"<code>KeyboardInput</code>  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseCh9329Model</code></p> <p>Represents the complete state of keyboard input for CH9329.</p> <p>This model directly corresponds to the USB HID keyboard packet structure, which supports up to 8 modifier keys and 6 simultaneous regular keys.</p> <p>Attributes:</p> Name Type Description <code>modifiers</code> <code>set[ModifierKey]</code> <p>Set of modifier keys (Ctrl, Shift, Alt, Meta).</p> <code>keys</code> <code>list[KeyCode]</code> <p>List of regular keys (maximum 6 keys).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If more than 6 keys are provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Single key with modifiers\n&gt;&gt;&gt; state = KeyboardInput(\n...     modifiers={ModifierKey.KEY_LEFTCTRL, ModifierKey.KEY_LEFTSHIFT},\n...     keys=[KeyCode.KEY_A]\n... )\n&gt;&gt;&gt; # Multiple keys pressed simultaneously\n&gt;&gt;&gt; state = KeyboardInput(\n...     modifiers={ModifierKey.KEY_LEFTSHIFT},\n...     keys=[KeyCode.KEY_A, KeyCode.KEY_B, KeyCode.KEY_C]\n... )\n&gt;&gt;&gt; # Maximum 6 keys\n&gt;&gt;&gt; state = KeyboardInput(\n...     keys=[KeyCode.KEY_A, KeyCode.KEY_B, KeyCode.KEY_C,\n...           KeyCode.KEY_D, KeyCode.KEY_E, KeyCode.KEY_F]\n... )\n</code></pre> Show JSON schema: <pre><code>{\n  \"$defs\": {\n    \"KeyCode\": {\n      \"description\": \"Keyboard key codes for CH9329 device.\\n\\nThese values follow evdev key code naming and values.\",\n      \"enum\": [\n        28,\n        1,\n        14,\n        15,\n        57,\n        41,\n        11,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        10,\n        30,\n        48,\n        46,\n        32,\n        18,\n        33,\n        34,\n        35,\n        23,\n        36,\n        37,\n        38,\n        50,\n        49,\n        24,\n        25,\n        16,\n        19,\n        31,\n        20,\n        22,\n        47,\n        17,\n        45,\n        21,\n        44,\n        12,\n        13,\n        26,\n        27,\n        43,\n        39,\n        40,\n        51,\n        52,\n        53,\n        124,\n        89\n      ],\n      \"title\": \"KeyCode\",\n      \"type\": \"integer\"\n    },\n    \"ModifierKey\": {\n      \"description\": \"Keyboard modifier key constants.\\n\\nThese values follow evdev key code naming and values.\",\n      \"enum\": [\n        29,\n        97,\n        42,\n        54,\n        56,\n        100,\n        125,\n        126\n      ],\n      \"title\": \"ModifierKey\",\n      \"type\": \"integer\"\n    }\n  },\n  \"description\": \"Represents the complete state of keyboard input for CH9329.\\n\\nThis model directly corresponds to the USB HID keyboard packet structure,\\nwhich supports up to 8 modifier keys and 6 simultaneous regular keys.\\n\\nAttributes:\\n    modifiers: Set of modifier keys (Ctrl, Shift, Alt, Meta).\\n    keys: List of regular keys (maximum 6 keys).\\n\\nRaises:\\n    ValueError: If more than 6 keys are provided.\\n\\nExamples:\\n    &gt;&gt;&gt; # Single key with modifiers\\n    &gt;&gt;&gt; state = KeyboardInput(\\n    ...     modifiers={ModifierKey.KEY_LEFTCTRL, ModifierKey.KEY_LEFTSHIFT},\\n    ...     keys=[KeyCode.KEY_A]\\n    ... )\\n    &gt;&gt;&gt; # Multiple keys pressed simultaneously\\n    &gt;&gt;&gt; state = KeyboardInput(\\n    ...     modifiers={ModifierKey.KEY_LEFTSHIFT},\\n    ...     keys=[KeyCode.KEY_A, KeyCode.KEY_B, KeyCode.KEY_C]\\n    ... )\\n    &gt;&gt;&gt; # Maximum 6 keys\\n    &gt;&gt;&gt; state = KeyboardInput(\\n    ...     keys=[KeyCode.KEY_A, KeyCode.KEY_B, KeyCode.KEY_C,\\n    ...           KeyCode.KEY_D, KeyCode.KEY_E, KeyCode.KEY_F]\\n    ... )\",\n  \"properties\": {\n    \"modifiers\": {\n      \"items\": {\n        \"$ref\": \"#/$defs/ModifierKey\"\n      },\n      \"title\": \"Modifiers\",\n      \"type\": \"array\",\n      \"uniqueItems\": true\n    },\n    \"keys\": {\n      \"items\": {\n        \"$ref\": \"#/$defs/KeyCode\"\n      },\n      \"maxItems\": 6,\n      \"title\": \"Keys\",\n      \"type\": \"array\"\n    }\n  },\n  \"title\": \"KeyboardInput\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Fields:</p> <ul> <li> <code>modifiers</code>                 (<code>set[ModifierKey]</code>)             </li> <li> <code>keys</code>                 (<code>list[KeyCode]</code>)             </li> </ul>"},{"location":"api/models/#ch9329py.models.MouseInput","title":"<code>MouseInput</code>  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseCh9329Model</code></p> <p>Represents the complete state of mouse input for CH9329.</p> <p>This model corresponds to the USB HID mouse relative movement packet, which supports multiple simultaneous button presses, relative movement, and scroll wheel input.</p> <p>Attributes:</p> Name Type Description <code>buttons</code> <code>set[MouseButton]</code> <p>Set of mouse buttons currently pressed.</p> <code>x</code> <code>int</code> <p>Relative X movement (-128 to 127).</p> <code>y</code> <code>int</code> <p>Relative Y movement (-128 to 127).</p> <code>scroll</code> <code>int</code> <p>Scroll wheel movement (-127 to 127).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If movement or scroll values are out of range.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Move right and down\n&gt;&gt;&gt; state = MouseInput(x=10, y=10)\n&gt;&gt;&gt; # Left button pressed while moving\n&gt;&gt;&gt; state = MouseInput(\n...     buttons={MouseButton.BTN_LEFT},\n...     x=5,\n...     y=-5\n... )\n&gt;&gt;&gt; # Multiple buttons with scroll\n&gt;&gt;&gt; state = MouseInput(\n...     buttons={MouseButton.BTN_LEFT, MouseButton.BTN_RIGHT},\n...     scroll=3\n... )\n&gt;&gt;&gt; # Release all buttons (no movement)\n&gt;&gt;&gt; state = MouseInput()\n</code></pre> Show JSON schema: <pre><code>{\n  \"$defs\": {\n    \"MouseButton\": {\n      \"description\": \"Mouse button constants for CH9329 device.\\n\\nThese values follow evdev button code naming and values.\",\n      \"enum\": [\n        272,\n        273,\n        274\n      ],\n      \"title\": \"MouseButton\",\n      \"type\": \"integer\"\n    }\n  },\n  \"description\": \"Represents the complete state of mouse input for CH9329.\\n\\nThis model corresponds to the USB HID mouse relative movement packet,\\nwhich supports multiple simultaneous button presses, relative movement,\\nand scroll wheel input.\\n\\nAttributes:\\n    buttons: Set of mouse buttons currently pressed.\\n    x: Relative X movement (-128 to 127).\\n    y: Relative Y movement (-128 to 127).\\n    scroll: Scroll wheel movement (-127 to 127).\\n\\nRaises:\\n    ValueError: If movement or scroll values are out of range.\\n\\nExamples:\\n    &gt;&gt;&gt; # Move right and down\\n    &gt;&gt;&gt; state = MouseInput(x=10, y=10)\\n    &gt;&gt;&gt; # Left button pressed while moving\\n    &gt;&gt;&gt; state = MouseInput(\\n    ...     buttons={MouseButton.BTN_LEFT},\\n    ...     x=5,\\n    ...     y=-5\\n    ... )\\n    &gt;&gt;&gt; # Multiple buttons with scroll\\n    &gt;&gt;&gt; state = MouseInput(\\n    ...     buttons={MouseButton.BTN_LEFT, MouseButton.BTN_RIGHT},\\n    ...     scroll=3\\n    ... )\\n    &gt;&gt;&gt; # Release all buttons (no movement)\\n    &gt;&gt;&gt; state = MouseInput()\",\n  \"properties\": {\n    \"buttons\": {\n      \"items\": {\n        \"$ref\": \"#/$defs/MouseButton\"\n      },\n      \"title\": \"Buttons\",\n      \"type\": \"array\",\n      \"uniqueItems\": true\n    },\n    \"x\": {\n      \"default\": 0,\n      \"maximum\": 127,\n      \"minimum\": -128,\n      \"title\": \"X\",\n      \"type\": \"integer\"\n    },\n    \"y\": {\n      \"default\": 0,\n      \"maximum\": 127,\n      \"minimum\": -128,\n      \"title\": \"Y\",\n      \"type\": \"integer\"\n    },\n    \"scroll\": {\n      \"default\": 0,\n      \"maximum\": 127,\n      \"minimum\": -127,\n      \"title\": \"Scroll\",\n      \"type\": \"integer\"\n    }\n  },\n  \"title\": \"MouseInput\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Fields:</p> <ul> <li> <code>buttons</code>                 (<code>set[MouseButton]</code>)             </li> <li> <code>x</code>                 (<code>int</code>)             </li> <li> <code>y</code>                 (<code>int</code>)             </li> <li> <code>scroll</code>                 (<code>int</code>)             </li> </ul>"},{"location":"api/models/#ch9329py.models.MediaKeyInput","title":"<code>MediaKeyInput</code>  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseCh9329Model</code></p> <p>Represents media key input for CH9329.</p> <p>This model corresponds to the USB HID media control packet. Unlike keyboard input which supports 6 simultaneous keys, media keys only support single key press at a time.</p> <p>Attributes:</p> Name Type Description <code>keys</code> <code>list[MediaKey]</code> <p>List of media keys (maximum 1 key). Empty list releases all keys.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If more than 1 key is provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Mute audio (press)\n&gt;&gt;&gt; input_data = MediaKeyInput(keys=[MediaKey.KEY_MUTE])\n&gt;&gt;&gt; # Play/pause media (press)\n&gt;&gt;&gt; input_data = MediaKeyInput(keys=[MediaKey.KEY_PLAYPAUSE])\n&gt;&gt;&gt; # Adjust volume (press)\n&gt;&gt;&gt; input_data = MediaKeyInput(keys=[MediaKey.KEY_VOLUMEUP])\n&gt;&gt;&gt; # Release all keys\n&gt;&gt;&gt; input_data = MediaKeyInput(keys=[])\n&gt;&gt;&gt; # or simply\n&gt;&gt;&gt; input_data = MediaKeyInput()\n</code></pre> Show JSON schema: <pre><code>{\n  \"$defs\": {\n    \"MediaKey\": {\n      \"description\": \"Media control key constants.\\n\\nThese values follow evdev key code naming convention.\\nValues are tuples of (byte1, byte2, byte3, byte4) that represent\\nthe media control packet data.\",\n      \"enum\": [\n        [\n          2,\n          128,\n          0,\n          0\n        ],\n        [\n          2,\n          64,\n          0,\n          0\n        ],\n        [\n          2,\n          32,\n          0,\n          0\n        ],\n        [\n          2,\n          16,\n          0,\n          0\n        ],\n        [\n          2,\n          8,\n          0,\n          0\n        ],\n        [\n          2,\n          4,\n          0,\n          0\n        ],\n        [\n          2,\n          2,\n          0,\n          0\n        ],\n        [\n          2,\n          1,\n          0,\n          0\n        ]\n      ],\n      \"title\": \"MediaKey\",\n      \"type\": \"array\"\n    }\n  },\n  \"description\": \"Represents media key input for CH9329.\\n\\nThis model corresponds to the USB HID media control packet. Unlike keyboard\\ninput which supports 6 simultaneous keys, media keys only support single\\nkey press at a time.\\n\\nAttributes:\\n    keys: List of media keys (maximum 1 key). Empty list releases all keys.\\n\\nRaises:\\n    ValueError: If more than 1 key is provided.\\n\\nExamples:\\n    &gt;&gt;&gt; # Mute audio (press)\\n    &gt;&gt;&gt; input_data = MediaKeyInput(keys=[MediaKey.KEY_MUTE])\\n    &gt;&gt;&gt; # Play/pause media (press)\\n    &gt;&gt;&gt; input_data = MediaKeyInput(keys=[MediaKey.KEY_PLAYPAUSE])\\n    &gt;&gt;&gt; # Adjust volume (press)\\n    &gt;&gt;&gt; input_data = MediaKeyInput(keys=[MediaKey.KEY_VOLUMEUP])\\n    &gt;&gt;&gt; # Release all keys\\n    &gt;&gt;&gt; input_data = MediaKeyInput(keys=[])\\n    &gt;&gt;&gt; # or simply\\n    &gt;&gt;&gt; input_data = MediaKeyInput()\",\n  \"properties\": {\n    \"keys\": {\n      \"items\": {\n        \"$ref\": \"#/$defs/MediaKey\"\n      },\n      \"maxItems\": 1,\n      \"title\": \"Keys\",\n      \"type\": \"array\"\n    }\n  },\n  \"title\": \"MediaKeyInput\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Fields:</p> <ul> <li> <code>keys</code>                 (<code>list[MediaKey]</code>)             </li> </ul>"},{"location":"api/protocol/","title":"Protocol Module","text":""},{"location":"api/protocol/#ch9329py.protocol","title":"<code>protocol</code>","text":"<p>CH9329 protocol packet building.</p> <p>This module contains the protocol layer for building packets that the CH9329 device understands. All packet building logic is isolated here for easier testing and maintenance.</p>"},{"location":"api/protocol/#ch9329py.protocol-classes","title":"Classes","text":""},{"location":"api/protocol/#ch9329py.protocol.CH9329Protocol","title":"<code>CH9329Protocol</code>","text":"<p>Protocol handler for CH9329 USB HID device.</p> <p>This class provides static methods for building various types of packets that can be sent to the CH9329 device. All methods return bytes objects that can be directly sent over serial communication.</p> Packet structure <ul> <li>Header: 2 bytes (0x57, 0xAB)</li> <li>Address: 1 byte (0x00)</li> <li>Command: 1 byte (varies by packet type)</li> <li>Length: 1 byte (length of data section)</li> <li>Data: variable length (depends on command)</li> <li>Checksum: 1 byte (sum of all previous bytes &amp; 0xFF)</li> </ul>"},{"location":"api/protocol/#ch9329py.protocol.CH9329Protocol-functions","title":"Functions","text":""},{"location":"api/protocol/#ch9329py.protocol.CH9329Protocol.build_keyboard_press_packet","title":"<code>build_keyboard_press_packet(modifier, keycode)</code>  <code>staticmethod</code>","text":"<p>Build a keyboard key press packet.</p> <p>Parameters:</p> Name Type Description Default <code>modifier</code> <code>int</code> <p>Modifier key byte (0x00 for none, 0x01 for ctrl,       0x02 for shift, 0x04 for alt, 0x08 for windows).</p> required <code>keycode</code> <code>int</code> <p>USB HID keycode for the key to press.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Keyboard press packet as bytes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CH9329Protocol.build_keyboard_press_packet(0x02, 0x04)\nb'W\\xab\\x00\\x02\\x08\\x02\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x10'\n</code></pre> Source code in <code>src/ch9329py/protocol.py</code> <pre><code>@staticmethod\ndef build_keyboard_press_packet(modifier: int, keycode: int) -&gt; bytes:\n    r\"\"\"Build a keyboard key press packet.\n\n    Args:\n        modifier: Modifier key byte (0x00 for none, 0x01 for ctrl,\n                  0x02 for shift, 0x04 for alt, 0x08 for windows).\n        keycode: USB HID keycode for the key to press.\n\n    Returns:\n        Keyboard press packet as bytes.\n\n    Examples:\n        &gt;&gt;&gt; CH9329Protocol.build_keyboard_press_packet(0x02, 0x04)\n        b'W\\xab\\x00\\x02\\x08\\x02\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x10'\n    \"\"\"\n    data = [modifier, 0x00, keycode, 0x00, 0x00, 0x00, 0x00, 0x00]\n    return CH9329Protocol._build_packet(CH9329Protocol._CMD_KEYBOARD, data)\n</code></pre>"},{"location":"api/protocol/#ch9329py.protocol.CH9329Protocol.build_keyboard_release_packet","title":"<code>build_keyboard_release_packet()</code>  <code>staticmethod</code>","text":"<p>Build a keyboard key release packet.</p> <p>This packet releases all pressed keys.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Keyboard release packet as bytes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CH9329Protocol.build_keyboard_release_packet()\nb'W\\xab\\x00\\x02\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0c'\n</code></pre> Source code in <code>src/ch9329py/protocol.py</code> <pre><code>@staticmethod\ndef build_keyboard_release_packet() -&gt; bytes:\n    r\"\"\"Build a keyboard key release packet.\n\n    This packet releases all pressed keys.\n\n    Returns:\n        Keyboard release packet as bytes.\n\n    Examples:\n        &gt;&gt;&gt; CH9329Protocol.build_keyboard_release_packet()\n        b'W\\xab\\x00\\x02\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0c'\n    \"\"\"\n    data = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n    return CH9329Protocol._build_packet(CH9329Protocol._CMD_KEYBOARD, data)\n</code></pre>"},{"location":"api/protocol/#ch9329py.protocol.CH9329Protocol.build_mouse_abs_packet","title":"<code>build_mouse_abs_packet(button, x, y)</code>  <code>staticmethod</code>","text":"<p>Build a mouse absolute position packet.</p> <p>Parameters:</p> Name Type Description Default <code>button</code> <code>int</code> <p>Button state byte (0x00 for none, 0x01 for left,     0x02 for right, 0x04 for middle).</p> required <code>x</code> <code>int</code> <p>Absolute X coordinate (0-4095).</p> required <code>y</code> <code>int</code> <p>Absolute Y coordinate (0-4095).</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Mouse absolute position packet as bytes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CH9329Protocol.build_mouse_abs_packet(0x00, 0, 0)\nb'W\\xab\\x00\\x04\\x07\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x10'\n</code></pre> Source code in <code>src/ch9329py/protocol.py</code> <pre><code>@staticmethod\ndef build_mouse_abs_packet(button: int, x: int, y: int) -&gt; bytes:\n    r\"\"\"Build a mouse absolute position packet.\n\n    Args:\n        button: Button state byte (0x00 for none, 0x01 for left,\n                0x02 for right, 0x04 for middle).\n        x: Absolute X coordinate (0-4095).\n        y: Absolute Y coordinate (0-4095).\n\n    Returns:\n        Mouse absolute position packet as bytes.\n\n    Examples:\n        &gt;&gt;&gt; CH9329Protocol.build_mouse_abs_packet(0x00, 0, 0)\n        b'W\\xab\\x00\\x04\\x07\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x10'\n    \"\"\"\n    # Clamp coordinates to valid range\n    x = max(0, min(4095, x))\n    y = max(0, min(4095, y))\n\n    x_low = x &amp; 0xFF\n    x_high = (x &gt;&gt; 8) &amp; 0xFF\n    y_low = y &amp; 0xFF\n    y_high = (y &gt;&gt; 8) &amp; 0xFF\n\n    data = [0x02, button, x_low, x_high, y_low, y_high, 0x00]\n    return CH9329Protocol._build_packet(CH9329Protocol._CMD_MOUSE_ABS, data)\n</code></pre>"},{"location":"api/protocol/#ch9329py.protocol.CH9329Protocol.build_mouse_rel_packet","title":"<code>build_mouse_rel_packet(button, x, y, scroll)</code>  <code>staticmethod</code>","text":"<p>Build a mouse relative movement packet.</p> <p>Parameters:</p> Name Type Description Default <code>button</code> <code>int</code> <p>Button state byte (0x00 for none, 0x01 for left,     0x02 for right, 0x04 for middle).</p> required <code>x</code> <code>int</code> <p>Relative X movement (-127 to 127).</p> required <code>y</code> <code>int</code> <p>Relative Y movement (-127 to 127).</p> required <code>scroll</code> <code>int</code> <p>Scroll wheel movement (-127 to 127).</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Mouse relative movement packet as bytes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CH9329Protocol.build_mouse_rel_packet(0x00, 10, 20, 0)\nb'W\\xab\\x00\\x05\\x05\\x01\\x00\\n\\x14\\x00+'\n</code></pre> Source code in <code>src/ch9329py/protocol.py</code> <pre><code>@staticmethod\ndef build_mouse_rel_packet(button: int, x: int, y: int, scroll: int) -&gt; bytes:\n    r\"\"\"Build a mouse relative movement packet.\n\n    Args:\n        button: Button state byte (0x00 for none, 0x01 for left,\n                0x02 for right, 0x04 for middle).\n        x: Relative X movement (-127 to 127).\n        y: Relative Y movement (-127 to 127).\n        scroll: Scroll wheel movement (-127 to 127).\n\n    Returns:\n        Mouse relative movement packet as bytes.\n\n    Examples:\n        &gt;&gt;&gt; CH9329Protocol.build_mouse_rel_packet(0x00, 10, 20, 0)\n        b'W\\xab\\x00\\x05\\x05\\x01\\x00\\n\\x14\\x00+'\n    \"\"\"\n    # Clamp values to valid range\n    x = max(-128, min(127, x))\n    y = max(-128, min(127, y))\n    scroll = max(-127, min(127, scroll))\n\n    # Convert negative values to two's complement\n    x_byte = x if x &gt;= 0 else 0x100 + x\n    y_byte = y if y &gt;= 0 else 0x100 + y\n    scroll_byte = scroll if scroll &gt;= 0 else 0x100 + scroll\n\n    data = [0x01, button, x_byte, y_byte, scroll_byte]\n    return CH9329Protocol._build_packet(CH9329Protocol._CMD_MOUSE_REL, data)\n</code></pre>"},{"location":"api/protocol/#ch9329py.protocol.CH9329Protocol.build_media_press_packet","title":"<code>build_media_press_packet(data0, data1, data2, data3)</code>  <code>staticmethod</code>","text":"<p>Build a media key press packet.</p> <p>Parameters:</p> Name Type Description Default <code>data0</code> <code>int</code> <p>First data byte (usually 0x02).</p> required <code>data1</code> <code>int</code> <p>Second data byte (media key code).</p> required <code>data2</code> <code>int</code> <p>Third data byte (usually 0x00).</p> required <code>data3</code> <code>int</code> <p>Fourth data byte (usually 0x00).</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Media key press packet as bytes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CH9329Protocol.build_media_press_packet(0x02, 0x04, 0x00, 0x00)\nb'W\\xab\\x00\\x03\\x04\\x02\\x04\\x00\\x00\\x11'\n</code></pre> Source code in <code>src/ch9329py/protocol.py</code> <pre><code>@staticmethod\ndef build_media_press_packet(\n    data0: int, data1: int, data2: int, data3: int\n) -&gt; bytes:\n    r\"\"\"Build a media key press packet.\n\n    Args:\n        data0: First data byte (usually 0x02).\n        data1: Second data byte (media key code).\n        data2: Third data byte (usually 0x00).\n        data3: Fourth data byte (usually 0x00).\n\n    Returns:\n        Media key press packet as bytes.\n\n    Examples:\n        &gt;&gt;&gt; CH9329Protocol.build_media_press_packet(0x02, 0x04, 0x00, 0x00)\n        b'W\\xab\\x00\\x03\\x04\\x02\\x04\\x00\\x00\\x11'\n    \"\"\"\n    data = [data0, data1, data2, data3]\n    return CH9329Protocol._build_packet(CH9329Protocol._CMD_MEDIA, data)\n</code></pre>"},{"location":"api/protocol/#ch9329py.protocol.CH9329Protocol.build_media_release_packet","title":"<code>build_media_release_packet()</code>  <code>staticmethod</code>","text":"<p>Build a media key release packet.</p> <p>This packet releases all pressed media keys.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Media key release packet as bytes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CH9329Protocol.build_media_release_packet()\nb'W\\xab\\x00\\x03\\x04\\x02\\x00\\x00\\x00\\x0b'\n</code></pre> Source code in <code>src/ch9329py/protocol.py</code> <pre><code>@staticmethod\ndef build_media_release_packet() -&gt; bytes:\n    r\"\"\"Build a media key release packet.\n\n    This packet releases all pressed media keys.\n\n    Returns:\n        Media key release packet as bytes.\n\n    Examples:\n        &gt;&gt;&gt; CH9329Protocol.build_media_release_packet()\n        b'W\\xab\\x00\\x03\\x04\\x02\\x00\\x00\\x00\\x0b'\n    \"\"\"\n    data = [0x02, 0x00, 0x00, 0x00]\n    return CH9329Protocol._build_packet(CH9329Protocol._CMD_MEDIA, data)\n</code></pre>"}]}